"""
The Orchestrator — Master / Workers
===================================
Global Scanner (Master) + Execution Engine (Workers).
Centralized: one scanner, multi-user execution.
"""

from __future__ import annotations

import asyncio
import json
from dataclasses import dataclass
from datetime import datetime, timezone
from typing import Any, Optional

import httpx
import structlog

from api.websocket_manager import engine_logs_manager
from db.credentials import get_polymarket_credentials_decrypted
from db.models import BotInstance, BotStatus, TradeLog, init_db
from db.session import get_session

logger = structlog.get_logger()

# Task handle for lifespan shutdown
_scanner_task: Optional[asyncio.Task] = None


# -----------------------------------------------------------------------------
# TradeSignal — Output of Global Scanner
# -----------------------------------------------------------------------------


@dataclass
class TradeSignal:
    """Signal generated by the IA after market analysis."""

    market_id: str
    market_question: str
    ia_probability: float  # 0-1
    confidence: float  # 0-1
    recommended_side: str  # YES | NO
    market_price: float  # Current YES price
    edge_pct: float  # |ia_probability - market_price| * 100


# -----------------------------------------------------------------------------
# Global Scanner (Master Task)
# -----------------------------------------------------------------------------

GAMMA_API_URL = "https://gamma-api.polymarket.com/markets"


async def _fetch_polymarket_markets(limit: int = 5) -> list[dict[str, Any]]:
    """
    Fetch top markets by 24h volume from Polymarket Gamma API.
    Returns list of {market_id, question, yes_price, no_price, ...}.
    """
    try:
        async with httpx.AsyncClient(timeout=15.0) as client:
            resp = await client.get(
                GAMMA_API_URL,
                params={
                    "limit": limit,
                    "order": "volume24hr",
                    "ascending": "false",
                    "closed": "false",
                    "active": "true",
                },
            )
            resp.raise_for_status()
            data = resp.json()
    except Exception as e:
        logger.error("Polymarket fetch failed", error=str(e))
        return []

    markets: list[dict[str, Any]] = []
    for m in data:
        try:
            raw_prices = m.get("outcomePrices", "[]")
            if isinstance(raw_prices, str):
                prices = json.loads(raw_prices)
            else:
                prices = raw_prices or []
            yes_price = float(prices[0]) if len(prices) >= 1 else 0.5
            no_price = float(prices[1]) if len(prices) >= 2 else 1.0 - yes_price

            markets.append({
                "market_id": m.get("conditionId", m.get("id", "")),
                "question": m.get("question", ""),
                "yes_price": yes_price,
                "no_price": no_price,
                "volume24hr": float(m.get("volume24hr", 0) or 0),
                "liquidity": float(m.get("liquidityNum", m.get("liquidity", 0)) or 0),
            })
        except (json.JSONDecodeError, ValueError, TypeError) as e:
            logger.debug("Skip market parse error", error=str(e))
            continue

    logger.info("Polymarket markets fetched", count=len(markets))
    return markets


async def _mock_ia_analyze(market: dict) -> Optional[TradeSignal]:
    """
    Mock IA analysis — uses real market_id and prices from Polymarket.
    Generates random-ish probability to simulate edge detection.
    """
    import random

    logger.info("Mock API call: IA analysis", market_id=market.get("market_id", "")[:12])
    await asyncio.sleep(0.5)

    market_id = market.get("market_id", "unknown")
    question = market.get("question", "")
    yes_price = float(market.get("yes_price", 0.5))

    # Simulate IA: random prob with slight bias toward edge
    ia_prob = round(0.4 + random.random() * 0.3, 2)  # 0.40–0.70
    side = "YES" if ia_prob > yes_price else "NO"
    if side == "NO":
        ia_prob = 1 - ia_prob

    edge = abs(ia_prob - yes_price) * 100
    if edge < 5:
        return None

    return TradeSignal(
        market_id=market_id,
        market_question=question,
        ia_probability=ia_prob,
        confidence=0.75,
        recommended_side=side,
        market_price=yes_price,
        edge_pct=edge,
    )


async def global_scanner_loop() -> None:
    """
    Master task: infinite loop.
    Scans Polymarket (mock), calls IA (mock), sends TradeSignal to Execution Engine.
    """
    logger.info("Global Scanner started")

    while True:
        try:
            # 1. Fetch markets (real Polymarket Gamma API)
            markets = await _fetch_polymarket_markets(limit=5)
            if not markets:
                await asyncio.sleep(60)
                continue

            # 2. Analyze each market (mock IA, real data)
            for market in markets[:5]:
                signal = await _mock_ia_analyze(market)
                if signal:
                    logger.info("Edge detected", market_id=signal.market_id[:12], edge=signal.edge_pct)
                    await execution_engine(signal)
                    break  # One signal per cycle for simplicity

            await asyncio.sleep(60)

        except asyncio.CancelledError:
            logger.info("Global Scanner cancelled")
            raise
        except Exception as e:
            logger.error("Global Scanner error", error=str(e))
            await asyncio.sleep(60)


# -----------------------------------------------------------------------------
# Execution Engine (Workers)
# -----------------------------------------------------------------------------


def _kelly_position_size(
    bankroll: float,
    ia_probability: float,
    market_price: float,
    side: str,
    kelly_fraction: float = 0.25,
) -> float:
    """
    Kelly Criterion — fractional.
    f* = (bp - q) / b, with b = decimal odds.
    Mock: bankroll = 1000$.
    """
    if side == "YES":
        p = ia_probability
        b = (1 - market_price) / market_price if market_price > 0 else 1
    else:
        p = 1 - ia_probability
        b = market_price / (1 - market_price) if market_price < 1 else 1

    q = 1 - p
    f = (b * p - q) / b if b > 0 else 0
    f = max(0, min(f * kelly_fraction, 0.05 * bankroll))  # Cap 5% per trade
    return round(f, 2)


async def _send_log(user_id: int, message: str) -> None:
    """Push log message to user's WebSocket (Terminal)."""
    await engine_logs_manager.send_personal_message(message, user_id)


async def _execute_for_user(user_id: int, signal: TradeSignal) -> None:
    """
    Execute trade for one user: decrypt keys, Kelly, mock execute, insert TradeLog.
    Isolated: exception for user A does not affect user B.
    Sends log messages to WebSocket for real-time Terminal display.
    """
    try:
        init_db()
        with get_session() as session:
            creds = get_polymarket_credentials_decrypted(session, user_id)
            if not creds:
                logger.warning("No credentials for user", user_id=user_id)
                await _send_log(user_id, "[WARNING] No Polymarket credentials configured")
                return

            proxy_key, secret = creds
            bankroll = 1000.0  # Mock
            size = _kelly_position_size(
                bankroll=bankroll,
                ia_probability=signal.ia_probability,
                market_price=signal.market_price,
                side=signal.recommended_side,
            )

            if size <= 0:
                await _send_log(user_id, "[SKIP] Kelly size <= 0, no trade")
                return

            msg = f"[EXECUTION] Position opened on {signal.market_question[:50]}... — {signal.recommended_side} ${size:.2f}"
            logger.info(
                "Mock trade execution",
                user_id=user_id,
                market_id=signal.market_id[:12],
                side=signal.recommended_side,
                size_usd=size,
            )
            await _send_log(user_id, msg)
            await asyncio.sleep(1)  # Simulate network

            # Insert TradeLog
            trade = TradeLog(
                user_id=user_id,
                market_id=signal.market_id,
                market_question=signal.market_question,
                side=signal.recommended_side,
                size_usd=size,
                price=signal.market_price,
                ia_probability=signal.ia_probability,
                confidence=signal.confidence,
                kelly_fraction=0.25,
                status="FILLED",
                pnl=0.0,
            )
            session.add(trade)

            # Update BotInstance heartbeat & last_log
            bot = session.query(BotInstance).filter(BotInstance.user_id == user_id).first()
            if bot:
                bot.last_heartbeat = datetime.now(timezone.utc)
                bot.last_log = f"Executed {signal.recommended_side} on {signal.market_question[:40]}..."

            await _send_log(user_id, f"[OK] Trade logged — market {signal.market_id[:12]}...")

    except Exception as e:
        logger.error("Execution failed for user", user_id=user_id, error=str(e))
        await _send_log(user_id, f"[ERROR] {str(e)[:120]}")
        try:
            with get_session() as session:
                bot = session.query(BotInstance).filter(BotInstance.user_id == user_id).first()
                if bot:
                    bot.status = BotStatus.ERROR
                    bot.last_log = f"Error: {str(e)[:80]}"
        except Exception:
            pass


async def execution_engine(signal: TradeSignal) -> None:
    """
    Workers: find all RUNNING BotInstances, execute trade for each in parallel.
    """
    init_db()
    with get_session() as session:
        bots = session.query(BotInstance).filter(BotInstance.status == BotStatus.RUNNING).all()
        user_ids = [b.user_id for b in bots]

    if not user_ids:
        logger.info("No active bots to execute")
        return

    logger.info("Execution Engine: dispatching to users", count=len(user_ids), user_ids=user_ids)

    # Notify each connected user that we're dispatching
    for uid in user_ids:
        await engine_logs_manager.send_personal_message(
            f"[SCANNER] Edge detected — dispatching to {len(user_ids)} user(s)",
            uid,
        )

    tasks = [_execute_for_user(uid, signal) for uid in user_ids]
    await asyncio.gather(*tasks)


# -----------------------------------------------------------------------------
# Lifecycle
# -----------------------------------------------------------------------------


def start_scanner() -> asyncio.Task:
    """Start the Global Scanner in background. Returns the task."""
    global _scanner_task
    _scanner_task = asyncio.create_task(global_scanner_loop())
    return _scanner_task


async def stop_scanner() -> None:
    """Cancel the Global Scanner task."""
    global _scanner_task
    if _scanner_task:
        _scanner_task.cancel()
        try:
            await _scanner_task
        except asyncio.CancelledError:
            pass
        _scanner_task = None
        logger.info("Global Scanner stopped")
